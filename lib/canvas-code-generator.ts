export interface RectangleCommand {
  x: number
  y: number
  width: number
  height: number
  fillStyle: string
}

export interface GenerateCanvasCodeOptions {
  /** Skip pixels whose normalized alpha is at or below this threshold */
  alphaThreshold?: number
  /** Decimal precision for the generated alpha channel */
  alphaPrecision?: number
}

export interface CanvasCodeResult {
  code: string
  rectangleCount: number
  width: number
  height: number
  rectangles: RectangleCommand[]
}

const DEFAULT_OPTIONS: Required<GenerateCanvasCodeOptions> = {
  alphaThreshold: 0.01,
  alphaPrecision: 3
}

export function generateCanvasCodeFromImageData(
  imageData: ImageData,
  options: GenerateCanvasCodeOptions = {}
): CanvasCodeResult {
  const { alphaPrecision, alphaThreshold } = { ...DEFAULT_OPTIONS, ...options }
  const rectangles = imageDataToRectangles(imageData, {
    alphaPrecision,
    alphaThreshold
  })

  const publicRectangles: RectangleCommand[] = rectangles.map(
    ({ x, y, width, height, fillStyle }) => ({ x, y, width, height, fillStyle })
  )

  const code = rectanglesToCode(publicRectangles, imageData.width, imageData.height)

  return {
    code,
    rectangleCount: publicRectangles.length,
    width: imageData.width,
    height: imageData.height,
    rectangles: publicRectangles
  }
}

interface RowSegment {
  x: number
  width: number
  fillStyle: string
  key: string
}

interface RectangleInternal extends RectangleCommand {
  key: string
}

interface RectangleOptions {
  alphaThreshold: number
  alphaPrecision: number
}

function imageDataToRectangles(
  imageData: ImageData,
  options: RectangleOptions
): RectangleInternal[] {
  const { width, height, data } = imageData
  const rectangles: RectangleInternal[] = []
  let previousRow = new Map<string, RectangleInternal>()

  for (let y = 0; y < height; y++) {
    const segments = collectRowSegments({
      data,
      width,
      y,
      options
    })

    const currentRow = new Map<string, RectangleInternal>()

    for (const segment of segments) {
      const existing = previousRow.get(segment.key)
      if (existing && existing.y + existing.height === y) {
        existing.height += 1
        currentRow.set(segment.key, existing)
        previousRow.delete(segment.key)
      } else {
        const rect: RectangleInternal = {
          x: segment.x,
          y,
          width: segment.width,
          height: 1,
          fillStyle: segment.fillStyle,
          key: segment.key
        }
        currentRow.set(segment.key, rect)
      }
    }

    for (const leftover of previousRow.values()) {
      rectangles.push(leftover)
    }

    previousRow = currentRow
  }

  for (const leftover of previousRow.values()) {
    rectangles.push(leftover)
  }

  return rectangles
}

interface SegmentCollectorInput {
  data: Uint8ClampedArray
  width: number
  y: number
  options: RectangleOptions
}

function collectRowSegments({
  data,
  width,
  y,
  options
}: SegmentCollectorInput): RowSegment[] {
  const segments: RowSegment[] = []
  let currentColor: RowSegment | null = null

  for (let x = 0; x < width; x++) {
    const index = (y * width + x) * 4
    const red = data[index]
    const green = data[index + 1]
    const blue = data[index + 2]
    const alpha = data[index + 3] / 255

    if (alpha <= options.alphaThreshold) {
      if (currentColor) {
        segments.push(currentColor)
        currentColor = null
      }
      continue
    }

    const roundedAlpha = Number(alpha.toFixed(options.alphaPrecision))
    const key = `${red}:${green}:${blue}:${roundedAlpha}`
    const fillStyle = `rgba(${red}, ${green}, ${blue}, ${roundedAlpha})`

    if (!currentColor) {
      currentColor = { x, width: 1, fillStyle, key }
      continue
    }

    if (currentColor.key === key) {
      currentColor.width += 1
    } else {
      segments.push(currentColor)
      currentColor = { x, width: 1, fillStyle, key }
    }
  }

  if (currentColor) {
    segments.push(currentColor)
  }

  return segments
}

function rectanglesToCode(
  rectangles: RectangleCommand[],
  width: number,
  height: number
): string {
  const lines: string[] = []
  lines.push(`// Auto-generated by Canvas Code Maker`)
  lines.push(`const canvas = document.createElement('canvas')`)
  lines.push(`canvas.width = ${width}`)
  lines.push(`canvas.height = ${height}`)
  lines.push(`const ctx = canvas.getContext('2d')`)
  lines.push(`if (!ctx) throw new Error('Canvas 2D context not available')`)
  lines.push(`document.body.appendChild(canvas)`)
  lines.push('')

  let currentFill: string | null = null
  for (const rect of rectangles) {
    if (rect.fillStyle !== currentFill) {
      lines.push(`ctx.fillStyle = '${rect.fillStyle}'`)
      currentFill = rect.fillStyle
    }
    lines.push(`ctx.fillRect(${rect.x}, ${rect.y}, ${rect.width}, ${rect.height})`)
  }

  return lines.join('\n')
}
