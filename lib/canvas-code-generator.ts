export interface RectangleCommand {
  x: number
  y: number
  width: number
  height: number
  fillStyle: string
}

export interface GenerateCanvasCodeOptions {
  /** Skip pixels whose normalized alpha is at or below this threshold */
  alphaThreshold?: number
  /** Decimal precision for the generated alpha channel */
  alphaPrecision?: number
  /** Number of color buckets per channel used for quantization */
  colorBuckets?: number
  /** Box blur radius (in pixels) applied before quantization to reduce noise */
  blurRadius?: number
}

export interface CanvasCodeResult {
  code: string
  rectangleCount: number
  width: number
  height: number
  rectangles: RectangleCommand[]
}

const DEFAULT_OPTIONS: Required<GenerateCanvasCodeOptions> = {
  alphaThreshold: 0.01,
  alphaPrecision: 3,
  colorBuckets: 48,
  blurRadius: 0
}

export function generateCanvasCodeFromImageData(
  imageData: ImageData,
  options: GenerateCanvasCodeOptions = {}
): CanvasCodeResult {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }
  const { alphaPrecision, alphaThreshold, colorBuckets, blurRadius } = mergedOptions

  const preparedData = preparePixelSource(imageData, blurRadius)
  const quantizationLut = buildQuantizationLut(colorBuckets)

  const rectangles = imageDataToRectangles(
    preparedData,
    imageData.width,
    imageData.height,
    {
      alphaPrecision,
      alphaThreshold,
      quantizationLut
    }
  )

  const publicRectangles: RectangleCommand[] = rectangles.map(
    ({ x, y, width, height, fillStyle }) => ({ x, y, width, height, fillStyle })
  )

  const code = rectanglesToCode(publicRectangles, imageData.width, imageData.height)

  return {
    code,
    rectangleCount: publicRectangles.length,
    width: imageData.width,
    height: imageData.height,
    rectangles: publicRectangles
  }
}

interface RowSegment {
  x: number
  width: number
  fillStyle: string
  key: string
}

interface RectangleInternal extends RectangleCommand {
  key: string
}

interface RectangleOptions {
  alphaThreshold: number
  alphaPrecision: number
  quantizationLut: Uint8Array
}

function imageDataToRectangles(
  data: Uint8ClampedArray,
  width: number,
  height: number,
  options: RectangleOptions
): RectangleInternal[] {
  const rectangles: RectangleInternal[] = []
  let previousRow = new Map<string, RectangleInternal>()

  for (let y = 0; y < height; y++) {
    const segments = collectRowSegments({ data, width, y, options })

    const currentRow = new Map<string, RectangleInternal>()

    for (const segment of segments) {
      const existing = previousRow.get(segment.key)
      if (existing && existing.y + existing.height === y) {
        existing.height += 1
        currentRow.set(segment.key, existing)
        previousRow.delete(segment.key)
      } else {
        const rect: RectangleInternal = {
          x: segment.x,
          y,
          width: segment.width,
          height: 1,
          fillStyle: segment.fillStyle,
          key: segment.key
        }
        currentRow.set(segment.key, rect)
      }
    }

    for (const leftover of previousRow.values()) {
      rectangles.push(leftover)
    }

    previousRow = currentRow
  }

  for (const leftover of previousRow.values()) {
    rectangles.push(leftover)
  }

  return rectangles
}

interface SegmentCollectorInput {
  data: Uint8ClampedArray
  width: number
  y: number
  options: RectangleOptions
}

function collectRowSegments({
  data,
  width,
  y,
  options
}: SegmentCollectorInput): RowSegment[] {
  const segments: RowSegment[] = []
  let currentColor: RowSegment | null = null

  for (let x = 0; x < width; x++) {
    const index = (y * width + x) * 4
    const red = options.quantizationLut[data[index]]
    const green = options.quantizationLut[data[index + 1]]
    const blue = options.quantizationLut[data[index + 2]]
    const alpha = data[index + 3] / 255

    if (alpha <= options.alphaThreshold) {
      if (currentColor) {
        segments.push(currentColor)
        currentColor = null
      }
      continue
    }

    const roundedAlpha = Number(alpha.toFixed(options.alphaPrecision))
    const key = `${red}:${green}:${blue}:${roundedAlpha}`
    const fillStyle = `rgba(${red}, ${green}, ${blue}, ${roundedAlpha})`

    if (!currentColor) {
      currentColor = { x, width: 1, fillStyle, key }
      continue
    }

    if (currentColor.key === key) {
      currentColor.width += 1
    } else {
      segments.push(currentColor)
      currentColor = { x, width: 1, fillStyle, key }
    }
  }

  if (currentColor) {
    segments.push(currentColor)
  }

  return segments
}

function rectanglesToCode(
  rectangles: RectangleCommand[],
  width: number,
  height: number
): string {
  const lines: string[] = []
  lines.push(`// Auto-generated by Canvas Code Maker`)
  lines.push(`const canvas = document.createElement('canvas')`)
  lines.push(`canvas.width = ${width}`)
  lines.push(`canvas.height = ${height}`)
  lines.push(`const ctx = canvas.getContext('2d')`)
  lines.push(`if (!ctx) throw new Error('Canvas 2D context not available')`)
  lines.push(`document.body.appendChild(canvas)`)
  lines.push('')

  let currentFill: string | null = null
  for (const rect of rectangles) {
    if (rect.fillStyle !== currentFill) {
      lines.push(`ctx.fillStyle = '${rect.fillStyle}'`)
      currentFill = rect.fillStyle
    }
    lines.push(`ctx.fillRect(${rect.x}, ${rect.y}, ${rect.width}, ${rect.height})`)
  }

  return lines.join('\n')
}

function preparePixelSource(imageData: ImageData, blurRadius: number): Uint8ClampedArray {
  const source = new Uint8ClampedArray(imageData.data)
  if (blurRadius <= 0) {
    return source
  }
  return applyBoxBlur(source, imageData.width, imageData.height, blurRadius)
}

function buildQuantizationLut(bucketCount: number): Uint8Array {
  const clamped = Math.min(256, Math.max(2, Math.round(bucketCount)))
  const lut = new Uint8Array(256)
  const step = 255 / (clamped - 1)
  for (let value = 0; value < 256; value++) {
    lut[value] = Math.max(0, Math.min(255, Math.round(Math.round(value / step) * step)))
  }
  return lut
}

function applyBoxBlur(
  source: Uint8ClampedArray,
  width: number,
  height: number,
  radius: number
): Uint8ClampedArray {
  const temp = new Uint8ClampedArray(source.length)
  const result = new Uint8ClampedArray(source.length)
  const kernelSize = radius * 2 + 1

  // Horizontal pass
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let rSum = 0
      let gSum = 0
      let bSum = 0
      let aSum = 0
      for (let k = -radius; k <= radius; k++) {
        const clampedX = Math.min(width - 1, Math.max(0, x + k))
        const index = (y * width + clampedX) * 4
        rSum += source[index]
        gSum += source[index + 1]
        bSum += source[index + 2]
        aSum += source[index + 3]
      }
      const targetIndex = (y * width + x) * 4
      temp[targetIndex] = rSum / kernelSize
      temp[targetIndex + 1] = gSum / kernelSize
      temp[targetIndex + 2] = bSum / kernelSize
      temp[targetIndex + 3] = aSum / kernelSize
    }
  }

  // Vertical pass
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      let rSum = 0
      let gSum = 0
      let bSum = 0
      let aSum = 0
      for (let k = -radius; k <= radius; k++) {
        const clampedY = Math.min(height - 1, Math.max(0, y + k))
        const index = (clampedY * width + x) * 4
        rSum += temp[index]
        gSum += temp[index + 1]
        bSum += temp[index + 2]
        aSum += temp[index + 3]
      }
      const targetIndex = (y * width + x) * 4
      result[targetIndex] = rSum / kernelSize
      result[targetIndex + 1] = gSum / kernelSize
      result[targetIndex + 2] = bSum / kernelSize
      result[targetIndex + 3] = aSum / kernelSize
    }
  }

  return result
}
